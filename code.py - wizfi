import time
import board
import busio
import digitalio
import usb_hid
from adafruit_hid.keyboard import Keyboard
from adafruit_hid.keycode import Keycode
from adafruit_wizfiatcontrol import adafruit_wizfiatcontrol

### SETTINGS

# Wi-Fi Credentials
SSID = "PicoHID_Network"
PASSWORD = "testestest"

# Baud Rate
BAUD_RATE = 921600

# WizFi360 Pins
RX = board.GP5
TX = board.GP4
resetpin = digitalio.DigitalInOut(board.GP20)
rtspin = False

# Setup UART for WizFi360
uart = busio.UART(TX, RX, baudrate=BAUD_RATE, receiver_buffer_size=2048)

print("Initializing WizFi360...")
wizfi = adafruit_wizfiatcontrol.WizFi_ATcontrol(
    uart, BAUD_RATE, reset_pin=resetpin, rts_pin=rtspin, debug=True
)

print("Resetting WizFi360...")
wizfi.hard_reset()
time.sleep(2)

# Set WizFi360 to Station mode
wizfi.mode = 1

# Connect to Wi-Fi
print(f"Connecting to {SSID}...")
try:
    wizfi.join_AP(SSID, PASSWORD)
    print("Connected to Wi-Fi!")
except Exception as e:
    print(f"Wi-Fi connection failed: {e}")

# Get and print IP Address
ip = wizfi.local_ip
print(f"Connected! IP Address: {ip}")

# Enable multiple connections
wizfi.at_response("AT+CIPMUX=1", timeout=5)

# Start TCP server on port 12345
print("Starting TCP server on port 12345...")
wizfi.at_response("AT+CIPSERVER=1,12345", timeout=5)

# Set up HID keyboard
keyboard = Keyboard(usb_hid.devices)

# Mapping of received character codes to HID keycodes
key_map = {
    10: Keycode.ENTER,      # LF (Line Feed) as Enter
    13: Keycode.ENTER,      # Just in case CR is ever used
    127: Keycode.BACKSPACE,
    9: Keycode.TAB,
    27: "ESC",
    32: Keycode.SPACE,
}

arrow_keys = {
    218: Keycode.UP_ARROW,    # 218 for Up Arrow
    217: Keycode.DOWN_ARROW,  # 217 for Down Arrow
    216: Keycode.LEFT_ARROW,  # 216 for Left Arrow
    215: Keycode.RIGHT_ARROW, # 215 for Right Arrow
}

esc_sequence = []  # Buffer for handling multi-byte sequences (e.g., arrow keys)

print("Waiting for keycodes...")

while True:
    if uart.in_waiting:
        data = uart.read(uart.in_waiting).decode("utf-8")
        print(f"Received raw data: {data}")

        if "+IPD" in data:
            try:
                parts = data.split(":")
                if len(parts) > 1:
                    keycode = int(parts[1].strip())  # Extract keycode
                    print(f"Keycode received: {keycode}")

                    # Directly map the keycode to arrow keys
                    if keycode in arrow_keys:
                        print(f"Sending Arrow Key: {arrow_keys[keycode]}")  # Debugging
                        keyboard.press(arrow_keys[keycode])  # Press the arrow key
                        time.sleep(0.05)  # Wait a bit before releasing
                        keyboard.release_all()  # Release all keys to finalize the action

                    # Handle predefined mappings (Enter, Backspace, Tab, Space, etc.)
                    elif keycode in key_map:
                        keyboard.send(key_map[keycode])

                    # Handle Ctrl + [A-Z] (ASCII 1-26)
                    elif 1 <= keycode <= 26:
                        ctrl_char = chr(keycode + 64)  # Convert to uppercase letter
                        if hasattr(Keycode, ctrl_char):
                            keyboard.press(Keycode.CONTROL, getattr(Keycode, ctrl_char))
                            keyboard.release_all()

                    # Handle normal printable characters
                    elif 32 <= keycode <= 126:
                        char = chr(keycode)

                        if 'a' <= char <= 'z':  # Lowercase letters
                            keyboard.send(getattr(Keycode, char.upper()))
                        elif 'A' <= char <= 'Z':  # Uppercase letters (requires Shift)
                            keyboard.press(Keycode.SHIFT, getattr(Keycode, char))
                            keyboard.release_all()
                        elif keycode in key_map:  # Symbols like Space
                            keyboard.send(key_map[keycode])
                        else:
                            print(f"Unhandled key: {keycode}")  # Debugging output

            except ValueError:
                pass  # Ignore invalid data

    time.sleep(0.01)  # Prevent high CPU usage
