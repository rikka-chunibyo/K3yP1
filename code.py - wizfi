import time
import board
import busio
import digitalio
import usb_hid
from adafruit_hid.keyboard import Keyboard
from adafruit_hid.keycode import Keycode
from adafruit_wizfiatcontrol import adafruit_wizfiatcontrol

# Wi-Fi Credentials
SSID = "PicoHID_Network"
PASSWORD = "testestest"

# WizFi360 Pins
RX = board.GP5
TX = board.GP4
resetpin = digitalio.DigitalInOut(board.GP20)
rtspin = False

# Setup UART for WizFi360
uart = busio.UART(TX, RX, baudrate=115200, receiver_buffer_size=2048)

print("Initializing WizFi360...")
wizfi = adafruit_wizfiatcontrol.WizFi_ATcontrol(
    uart, 115200, reset_pin=resetpin, rts_pin=rtspin, debug=True
)

print("Resetting WizFi360...")
wizfi.hard_reset()
time.sleep(2)

# Set WizFi360 to Station mode
wizfi.mode = 1

# Connect to Wi-Fi
print(f"Connecting to {SSID} with password {PASSWORD}...")
try:
    join_cmd = f'AT+CWJAP="{SSID}","{PASSWORD}"'
    response = wizfi.at_response(join_cmd, timeout=10)
    print(f"Join response: {response}")
except TypeError as e:
    print(f"Error during connection: {e}") 

# Get and print IP Address
ip = wizfi.local_ip
print(f"Connected! IP Address: {ip}")

# Start HTTP server
print("Enabling multiple connections...")
wizfi.at_response("AT+CIPMUX=1", timeout=5)

print("Starting TCP server on port 80...")
response = wizfi.at_response("AT+CIPSERVER=1,80", timeout=5)
print(f"Server response: {response}")

# Set up HID keyboard
keyboard = Keyboard(usb_hid.devices)

# Mapping of received character codes to HID keycodes
key_map = {
    10: Keycode.ENTER,
    13: Keycode.ENTER,
    127: Keycode.BACKSPACE,
    9: Keycode.TAB,
    27: "ESC",
    32: Keycode.SPACE,
}

arrow_keys = {
    218: Keycode.UP_ARROW,
    217: Keycode.DOWN_ARROW,
    216: Keycode.LEFT_ARROW,
    215: Keycode.RIGHT_ARROW,
}

while True:
    if uart.in_waiting:
        response = uart.read(uart.in_waiting).decode("utf-8")
        print(f"Received: {response}")

        if "+IPD" in response:
            try:
                request = response.split("GET ")[1].split(" ")[0]  # Extract GET request
                key = int(request.split("=")[1])  # Extract keycode as integer
                print(f"Keycode received: {key}")

                # Send keypress based on received keycode
                if key in key_map:
                    keyboard.send(key_map[key])
                elif key in arrow_keys:
                    keyboard.send(arrow_keys[key])
                elif 1 <= key <= 26:  # Handle Ctrl+[A-Z]
                    ctrl_char = chr(key + 64)
                    if hasattr(Keycode, ctrl_char):
                        keyboard.press(Keycode.CONTROL, getattr(Keycode, ctrl_char))
                        keyboard.release_all()
                elif 32 <= key <= 126:  # Printable characters
                    char = chr(key)
                    if 'a' <= char <= 'z':
                        keyboard.send(getattr(Keycode, char.upper()))
                    elif 'A' <= char <= 'Z':
                        keyboard.press(Keycode.SHIFT, getattr(Keycode, char))
                        keyboard.release_all()
                    elif '0' <= char <= '9':
                        keyboard.send(getattr(Keycode, char))
                    else:
                        print(f"Unhandled key: {key}")

                # Send HTTP response
                wizfi.socket_send(0, "HTTP/1.1 200 OK\r\n\r\nKey Sent!")
                wizfi.socket_close(0)
            except:
                pass  # Ignore errors

    time.sleep(0.1)
